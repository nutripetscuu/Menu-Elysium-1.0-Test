-- ==========================================================================================
-- ==========================================================================================
--
--                               ELYSIUM DATABASE SCHEMA
--
-- This file is an aggregation of all SQL migrations. It represents the complete
-- database schema and can be used to recreate the database from scratch.
--
-- Generated by Gemini on: 2025-10-14
--
-- ==========================================================================================
-- ==========================================================================================



-- ==========================================================================================
-- MIGRATION: 001_initial_schema.sql
-- ==========================================================================================

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =====================================================
-- TABLE: categories
-- Stores menu categories (Calientes, Frappés, etc.)
-- =====================================================
CREATE TABLE categories (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL UNIQUE,
  icon TEXT NOT NULL, -- Icon name from Lucide React
  position INTEGER NOT NULL DEFAULT 0,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ
);

-- Index for active categories ordered by position
CREATE INDEX idx_categories_active_position ON categories(is_active, position) WHERE is_active = true;

-- =====================================================
-- TABLE: menu_items
-- Stores individual menu items with pricing
-- =====================================================
CREATE TABLE menu_items (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  category_id UUID NOT NULL REFERENCES categories(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT NOT NULL,

  -- Pricing: either single price OR medium/grande sizes
  price DECIMAL(10,2), -- Single price (e.g., 40.00)
  price_medium DECIMAL(10,2), -- Medium size price
  price_grande DECIMAL(10,2), -- Grande size price

  -- Media & metadata
  image_url TEXT,
  tags TEXT[] DEFAULT '{}', -- Array of tags: ["Popular", "Nuevo"]
  portion TEXT, -- Portion description (e.g., "Porción individual")

  -- Display & availability
  position INTEGER NOT NULL DEFAULT 0,
  is_available BOOLEAN NOT NULL DEFAULT true,

  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ,

  -- Constraints: Must have either single price OR both size prices
  CONSTRAINT price_check CHECK (
    (price IS NOT NULL AND price_medium IS NULL AND price_grande IS NULL) OR
    (price IS NULL AND price_medium IS NOT NULL AND price_grande IS NOT NULL)
  )
);

-- Index for category items ordered by position
CREATE INDEX idx_menu_items_category_position ON menu_items(category_id, position);
-- Index for available items
CREATE INDEX idx_menu_items_available ON menu_items(is_available) WHERE is_available = true;

-- =====================================================
-- TABLE: modifier_groups
-- Stores modifier group definitions (e.g., "Tipo de leche")
-- =====================================================
CREATE TABLE modifier_groups (
  id TEXT PRIMARY KEY, -- Human-readable ID (e.g., "milk_types")
  name TEXT NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('single', 'multiple', 'boolean')),
  required BOOLEAN NOT NULL DEFAULT false,
  min_selections INTEGER NOT NULL DEFAULT 0,
  max_selections INTEGER, -- NULL = unlimited
  position INTEGER NOT NULL DEFAULT 0, -- Display order
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ
);

-- =====================================================
-- TABLE: modifier_options
-- Stores individual options within modifier groups
-- =====================================================
CREATE TABLE modifier_options (
  id TEXT PRIMARY KEY, -- Human-readable ID (e.g., "milk_entera")
  modifier_group_id TEXT NOT NULL REFERENCES modifier_groups(id) ON DELETE CASCADE,
  label TEXT NOT NULL,
  price_modifier DECIMAL(10,2) NOT NULL DEFAULT 0.00, -- Can be positive or negative
  is_default BOOLEAN NOT NULL DEFAULT false,
  position INTEGER NOT NULL DEFAULT 0, -- Display order within group
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ
);

-- Index for modifier options by group
CREATE INDEX idx_modifier_options_group ON modifier_options(modifier_group_id, position);

-- =====================================================
-- TABLE: menu_item_modifiers
-- Junction table linking menu items to modifier groups
-- =====================================================
CREATE TABLE menu_item_modifiers (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  menu_item_id UUID NOT NULL REFERENCES menu_items(id) ON DELETE CASCADE,
  modifier_group_id TEXT NOT NULL REFERENCES modifier_groups(id) ON DELETE CASCADE,
  position INTEGER NOT NULL DEFAULT 0, -- Order in which modifiers appear
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Prevent duplicate modifier groups per menu item
  UNIQUE(menu_item_id, modifier_group_id)
);

-- Index for efficient lookup of modifiers for a menu item
CREATE INDEX idx_menu_item_modifiers_item ON menu_item_modifiers(menu_item_id, position);

-- =====================================================
-- TABLE: admin_users
-- Stores admin panel users
-- =====================================================
CREATE TABLE admin_users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  email TEXT NOT NULL UNIQUE,
  role TEXT NOT NULL CHECK (role IN ('admin', 'manager', 'editor')) DEFAULT 'admin',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_login TIMESTAMPTZ
);

-- Index for email lookup
CREATE INDEX idx_admin_users_email ON admin_users(email);

-- =====================================================
-- TRIGGERS: Auto-update updated_at timestamps
-- =====================================================
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_categories_updated_at BEFORE UPDATE ON categories
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_menu_items_updated_at BEFORE UPDATE ON menu_items
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_modifier_groups_updated_at BEFORE UPDATE ON modifier_groups
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_modifier_options_updated_at BEFORE UPDATE ON modifier_options
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- VIEWS: Convenience views for common queries
-- =====================================================

-- View: Full menu with items and modifiers
CREATE OR REPLACE VIEW menu_full AS
SELECT
  c.id as category_id,
  c.name as category_name,
  c.icon as category_icon,
  c.position as category_position,
  mi.id as item_id,
  mi.name as item_name,
  mi.description,
  mi.price,
  mi.price_medium,
  mi.price_grande,
  mi.image_url,
  mi.tags,
  mi.portion,
  mi.position as item_position,
  mi.is_available,
  COALESCE(
    json_agg(
      json_build_object(
        'modifier_group_id', mim.modifier_group_id,
        'position', mim.position
      ) ORDER BY mim.position
    ) FILTER (WHERE mim.modifier_group_id IS NOT NULL),
    '[]'::json
  ) as modifier_groups
FROM categories c
LEFT JOIN menu_items mi ON mi.category_id = c.id
LEFT JOIN menu_item_modifiers mim ON mim.menu_item_id = mi.id
WHERE c.is_active = true
GROUP BY c.id, c.name, c.icon, c.position, mi.id, mi.name, mi.description,
         mi.price, mi.price_medium, mi.price_grande, mi.image_url, mi.tags,
         mi.portion, mi.position, mi.is_available
ORDER BY c.position, mi.position;

-- =====================================================
-- COMMENTS: Table and column documentation
-- =====================================================
COMMENT ON TABLE categories IS 'Menu categories (e.g., Calientes, Frappés, Frescos)';
COMMENT ON TABLE menu_items IS 'Individual menu items with pricing and customization options';
COMMENT ON TABLE modifier_groups IS 'Customization groups (e.g., milk type, sauces, ingredients)';
COMMENT ON TABLE modifier_options IS 'Individual options within modifier groups';
COMMENT ON TABLE menu_item_modifiers IS 'Links menu items to their available modifier groups';
COMMENT ON TABLE admin_users IS 'Admin panel users with role-based access';

COMMENT ON COLUMN menu_items.price IS 'Single price for items without sizes';
COMMENT ON COLUMN menu_items.price_medium IS 'Medium size price (mutually exclusive with single price)';
COMMENT ON COLUMN menu_items.price_grande IS 'Grande size price (mutually exclusive with single price)';
COMMENT ON COLUMN modifier_options.price_modifier IS 'Additional cost (+) or discount (-) for this option';



-- ==========================================================================================
-- MIGRATION: 002_row_level_security.sql
-- ==========================================================================================

-- Enable Row Level Security on all tables
ALTER TABLE categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE menu_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE modifier_groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE modifier_options ENABLE ROW LEVEL SECURITY;
ALTER TABLE menu_item_modifiers ENABLE ROW LEVEL SECURITY;
ALTER TABLE admin_users ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- PUBLIC READ ACCESS
-- Allow anonymous users to read menu data
-- =====================================================

-- Categories: Public can read active categories
CREATE POLICY "Public can view active categories"
  ON categories FOR SELECT
  USING (is_active = true);

-- Menu Items: Public can read available items
CREATE POLICY "Public can view available menu items"
  ON menu_items FOR SELECT
  USING (is_available = true);

-- Modifier Groups: Public can read all modifier groups
CREATE POLICY "Public can view modifier groups"
  ON modifier_groups FOR SELECT
  USING (true);

-- Modifier Options: Public can read all modifier options
CREATE POLICY "Public can view modifier options"
  ON modifier_options FOR SELECT
  USING (true);

-- Menu Item Modifiers: Public can read modifier associations
CREATE POLICY "Public can view menu item modifiers"
  ON menu_item_modifiers FOR SELECT
  USING (true);

-- =====================================================
-- ADMIN WRITE ACCESS
-- Only authenticated admin users can modify data
-- =====================================================

-- Helper function to check if user is admin
CREATE OR REPLACE FUNCTION is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM admin_users
    WHERE id = auth.uid()
    AND role IN ('admin', 'manager', 'editor')
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Categories: Admin full access
CREATE POLICY "Admins can insert categories"
  ON categories FOR INSERT
  WITH CHECK (is_admin());

CREATE POLICY "Admins can update categories"
  ON categories FOR UPDATE
  USING (is_admin())
  WITH CHECK (is_admin());

CREATE POLICY "Admins can delete categories"
  ON categories FOR DELETE
  USING (is_admin());

-- Admin users can also view inactive categories
CREATE POLICY "Admins can view all categories"
  ON categories FOR SELECT
  USING (is_admin());

-- Menu Items: Admin full access
CREATE POLICY "Admins can insert menu items"
  ON menu_items FOR INSERT
  WITH CHECK (is_admin());

CREATE POLICY "Admins can update menu items"
  ON menu_items FOR UPDATE
  USING (is_admin())
  WITH CHECK (is_admin());

CREATE POLICY "Admins can delete menu items"
  ON menu_items FOR DELETE
  USING (is_admin());

-- Admins can view unavailable items
CREATE POLICY "Admins can view all menu items"
  ON menu_items FOR SELECT
  USING (is_admin());

-- Modifier Groups: Admin full access
CREATE POLICY "Admins can insert modifier groups"
  ON modifier_groups FOR INSERT
  WITH CHECK (is_admin());

CREATE POLICY "Admins can update modifier groups"
  ON modifier_groups FOR UPDATE
  USING (is_admin())
  WITH CHECK (is_admin());

CREATE POLICY "Admins can delete modifier groups"
  ON modifier_groups FOR DELETE
  USING (is_admin());

-- Modifier Options: Admin full access
CREATE POLICY "Admins can insert modifier options"
  ON modifier_options FOR INSERT
  WITH CHECK (is_admin());

CREATE POLICY "Admins can update modifier options"
  ON modifier_options FOR UPDATE
  USING (is_admin())
  WITH CHECK (is_admin());

CREATE POLICY "Admins can delete modifier options"
  ON modifier_options FOR DELETE
  USING (is_admin());

-- Menu Item Modifiers: Admin full access
CREATE POLICY "Admins can insert menu item modifiers"
  ON menu_item_modifiers FOR INSERT
  WITH CHECK (is_admin());

CREATE POLICY "Admins can update menu item modifiers"
  ON menu_item_modifiers FOR UPDATE
  USING (is_admin())
  WITH CHECK (is_admin());

CREATE POLICY "Admins can delete menu item modifiers"
  ON menu_item_modifiers FOR DELETE
  USING (is_admin());

-- =====================================================
-- ADMIN USERS TABLE POLICIES
-- =====================================================

-- Only super admins can manage admin users
CREATE POLICY "Super admins can view admin users"
  ON admin_users FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM admin_users
      WHERE id = auth.uid() AND role = 'admin'
    )
  );

CREATE POLICY "Super admins can insert admin users"
  ON admin_users FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM admin_users
      WHERE id = auth.uid() AND role = 'admin'
    )
  );

CREATE POLICY "Super admins can update admin users"
  ON admin_users FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM admin_users
      WHERE id = auth.uid() AND role = 'admin'
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM admin_users
      WHERE id = auth.uid() AND role = 'admin'
    )
  );

-- Admins can update their own last_login
CREATE POLICY "Admins can update own last_login"
  ON admin_users FOR UPDATE
  USING (id = auth.uid())
  WITH CHECK (id = auth.uid());

-- =====================================================
-- STORAGE POLICIES (for menu images)
-- =====================================================

-- Note: This assumes a storage bucket named 'menu-images' exists
-- Create bucket command (run separately in Supabase dashboard or CLI):
-- INSERT INTO storage.buckets (id, name, public) VALUES ('menu-images', 'menu-images', true);

-- Public can read images
-- CREATE POLICY "Public can view menu images"
--   ON storage.objects FOR SELECT
--   USING (bucket_id = 'menu-images');

-- Admins can upload/update/delete images
-- CREATE POLICY "Admins can manage menu images"
--   ON storage.objects FOR ALL
--   USING (bucket_id = 'menu-images' AND is_admin())
--   WITH CHECK (bucket_id = 'menu-images' AND is_admin());

-- =====================================================
-- COMMENTS
-- =====================================================
COMMENT ON FUNCTION is_admin() IS 'Helper function to check if current user is an authenticated admin';



-- ==========================================================================================
-- MIGRATION: 003_seed_modifier_groups.sql
-- ==========================================================================================

-- =====================================================
-- MILK TYPES
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('milk_types', 'Tipo de leche', 'single', true, 1, 1, 1);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('milk_entera', 'milk_types', 'Entera', 0.00, true, 1),
('milk_deslactosada', 'milk_types', 'Deslactosada', 0.00, false, 2),
('milk_coco', 'milk_types', 'Coco', 10.00, false, 3),
('milk_almendra', 'milk_types', 'Almendra', 10.00, false, 4);

-- =====================================================
-- MILK TO ACCOMPANY (for Americano)
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('milk_to_accompany', 'Tipo de leche para acompañar', 'single', false, 0, 1, 2);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('milk_accompany_entera', 'milk_to_accompany', 'Entera', 0.00, true, 1),
('milk_accompany_deslactosada', 'milk_to_accompany', 'Deslactosada', 0.00, false, 2),
('milk_accompany_coco', 'milk_to_accompany', 'Coco', 10.00, false, 3),
('milk_accompany_almendra', 'milk_to_accompany', 'Almendra', 10.00, false, 4);

-- =====================================================
-- ESSENCES
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('essences', 'Esencia', 'single', false, 0, 1, 3);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('essence_caramelo', 'essences', 'Caramelo', 0.00, false, 1),
('essence_vainilla', 'essences', 'Vainilla', 0.00, false, 2);

-- =====================================================
-- CINNAMON TOPPING
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('cinnamon_topping', 'Topping', 'boolean', false, 0, 1, 4);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('cinnamon_yes', 'cinnamon_topping', 'Canela', 0.00, false, 1);

-- =====================================================
-- TEA TYPES
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('tea_types', 'Tipo de té', 'single', true, 1, 1, 5);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('tea_manzanilla', 'tea_types', 'Manzanilla', 0.00, true, 1),
('tea_verde', 'tea_types', 'Verde', 0.00, false, 2),
('tea_menta', 'tea_types', 'Menta', 0.00, false, 3);

-- =====================================================
-- TEA PRESENTATION
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('tea_presentation', 'Presentación', 'single', true, 1, 1, 6);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('presentation_hot', 'tea_presentation', 'Caliente', 0.00, true, 1),
('presentation_iced', 'tea_presentation', 'En las rocas', 0.00, false, 2);

-- =====================================================
-- WHIPPED CREAM
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('whipped_cream', 'Decoración', 'single', true, 1, 1, 7);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('cream_yes', 'whipped_cream', 'Con crema batida', 0.00, true, 1),
('cream_no', 'whipped_cream', 'Sin crema batida', 0.00, false, 2);

-- =====================================================
-- TAPIOCA TOPPINGS (Multiple)
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('tapioca_toppings', 'Toppings', 'multiple', false, 0, 2, 8);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('tapioca_fresa', 'tapioca_toppings', 'Tapioca fresa', 20.00, false, 1),
('tapioca_tradicional', 'tapioca_toppings', 'Tapioca tradicional', 20.00, false, 2);

-- =====================================================
-- TAPIOCA FRESCOS (Boolean)
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('tapioca_frescos', 'Extras', 'boolean', false, 0, 1, 9);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('tapioca_fresa_single', 'tapioca_frescos', 'Tapioca de fresa', 20.00, false, 1);

-- =====================================================
-- SAUCES
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('sauces', 'Salsas', 'multiple', false, 0, 3, 10);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('sauce_macha', 'sauces', 'Macha', 0.00, false, 1),
('sauce_chipotle', 'sauces', 'Chipotle', 0.00, false, 2),
('sauce_casa', 'sauces', 'De la casa', 0.00, false, 3);

-- =====================================================
-- ADD EGG
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('add_egg', 'Extras', 'boolean', false, 0, 1, 11);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('extra_egg', 'add_egg', 'Agrega huevo', 15.00, false, 1);

-- =====================================================
-- FOOD ITEM INGREDIENTS - OLIMPO
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('olimpo_ingredients', 'Ingredientes (puedes excluir lo que no desees)', 'multiple', false, 0, 4, 20);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('ing_bistec', 'olimpo_ingredients', 'Bistec', 0.00, true, 1),
('ing_queso_olimpo', 'olimpo_ingredients', 'Queso', 0.00, true, 2),
('ing_lechuga_olimpo', 'olimpo_ingredients', 'Lechuga', 0.00, true, 3),
('ing_pimientos_olimpo', 'olimpo_ingredients', 'Pimientos salteados', 0.00, true, 4);

-- =====================================================
-- FOOD ITEM INGREDIENTS - ELISEO
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('eliseo_ingredients', 'Ingredientes (puedes excluir lo que no desees)', 'multiple', false, 0, 4, 21);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('ing_pollo_eliseo', 'eliseo_ingredients', 'Pollo', 0.00, true, 1),
('ing_queso_eliseo', 'eliseo_ingredients', 'Queso', 0.00, true, 2),
('ing_tocino', 'eliseo_ingredients', 'Tocino', 0.00, true, 3),
('ing_lechuga_eliseo', 'eliseo_ingredients', 'Lechuga', 0.00, true, 4);

-- =====================================================
-- FOOD ITEM INGREDIENTS - CELESTE
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('celeste_ingredients', 'Ingredientes (puedes excluir lo que no desees)', 'multiple', false, 0, 3, 22);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('ing_jamon', 'celeste_ingredients', 'Jamón', 0.00, true, 1),
('ing_queso_celeste', 'celeste_ingredients', 'Queso', 0.00, true, 2),
('ing_lechuga_celeste', 'celeste_ingredients', 'Lechuga', 0.00, true, 3);

-- =====================================================
-- FOOD ITEM INGREDIENTS - CAESAR SALAD
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('caesar_ingredients', 'Ingredientes (puedes excluir lo que no desees)', 'multiple', false, 0, 5, 23);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('ing_lechuga_orejona', 'caesar_ingredients', 'Lechuga orejona', 0.00, true, 1),
('ing_pollo_caesar', 'caesar_ingredients', 'Pollo', 0.00, true, 2),
('ing_queso_parmesano', 'caesar_ingredients', 'Queso parmesano', 0.00, true, 3),
('ing_aderezo_caesar', 'caesar_ingredients', 'Aderezo caesar', 0.00, true, 4),
('ing_pan', 'caesar_ingredients', 'Pan', 0.00, true, 5);

-- =====================================================
-- FOOD ITEM INGREDIENTS - ELYSIUM SALAD
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('elysium_ingredients', 'Ingredientes (puedes excluir lo que no desees)', 'multiple', false, 0, 7, 24);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('ing_lechuga_orejona_elysium', 'elysium_ingredients', 'Lechuga orejona', 0.00, true, 1),
('ing_espinaca', 'elysium_ingredients', 'Espinaca', 0.00, true, 2),
('ing_fresa', 'elysium_ingredients', 'Fresa', 0.00, true, 3),
('ing_arandanos', 'elysium_ingredients', 'Arándanos', 0.00, true, 4),
('ing_queso_cabra', 'elysium_ingredients', 'Queso de cabra', 0.00, true, 5),
('ing_nuez', 'elysium_ingredients', 'Nuez', 0.00, true, 6),
('ing_vinagreta', 'elysium_ingredients', 'Vinagreta de la casa', 0.00, true, 7);

-- =====================================================
-- FOOD ITEM INGREDIENTS - POLLO TOAST
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('pollo_toast_ingredients', 'Ingredientes (puedes excluir lo que no desees)', 'multiple', false, 0, 5, 25);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('ing_pollo_toast', 'pollo_toast_ingredients', 'Pollo', 0.00, true, 1),
('ing_pimientos_toast', 'pollo_toast_ingredients', 'Pimientos salteados', 0.00, true, 2),
('ing_salsa_casa', 'pollo_toast_ingredients', 'Salsa de la casa', 0.00, true, 3),
('ing_lechuga_toast', 'pollo_toast_ingredients', 'Lechuga fresca', 0.00, true, 4),
('ing_tomates_cherry', 'pollo_toast_ingredients', 'Tomates cherry', 0.00, true, 5);

-- =====================================================
-- FOOD ITEM INGREDIENTS - AVO TOAST
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('avo_toast_ingredients', 'Ingredientes (puedes excluir lo que no desees)', 'multiple', false, 0, 6, 26);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('ing_jocoque', 'avo_toast_ingredients', 'Jocoque', 0.00, true, 1),
('ing_aguacate', 'avo_toast_ingredients', 'Aguacate fresco', 0.00, true, 2),
('ing_ajonjoli', 'avo_toast_ingredients', 'Ajonjolí', 0.00, true, 3),
('ing_tomates_cherry_salteados', 'avo_toast_ingredients', 'Tomates cherry salteados', 0.00, true, 4),
('ing_lechuga_avo', 'avo_toast_ingredients', 'Lechuga', 0.00, true, 5),
('ing_tomates_cherry_frescos', 'avo_toast_ingredients', 'Tomates cherry frescos', 0.00, true, 6);

-- =====================================================
-- FOOD ITEM INGREDIENTS - PERA TOAST
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('pera_toast_ingredients', 'Ingredientes (puedes excluir lo que no desees)', 'multiple', false, 0, 7, 27);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('ing_queso_crema', 'pera_toast_ingredients', 'Queso crema', 0.00, true, 1),
('ing_pera', 'pera_toast_ingredients', 'Láminas de pera', 0.00, true, 2),
('ing_queso_panela', 'pera_toast_ingredients', 'Queso panela', 0.00, true, 3),
('ing_nueces', 'pera_toast_ingredients', 'Nueces', 0.00, true, 4),
('ing_miel', 'pera_toast_ingredients', 'Miel', 0.00, true, 5),
('ing_fresas', 'pera_toast_ingredients', 'Fresas', 0.00, true, 6),
('ing_moras', 'pera_toast_ingredients', 'Moras', 0.00, true, 7);

-- =====================================================
-- FOOD ITEM INGREDIENTS - PAPAS CASA
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('papas_casa_ingredients', 'Ingredientes (puedes excluir lo que no desees)', 'multiple', false, 0, 3, 28);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('ing_camote', 'papas_casa_ingredients', 'Camote', 0.00, true, 1),
('ing_papas_fritas', 'papas_casa_ingredients', 'Papas fritas', 0.00, true, 2),
('ing_catsup_chile', 'papas_casa_ingredients', 'Salsa catsup con chile quebrado', 0.00, true, 3);

-- =====================================================
-- FOOD ITEM INGREDIENTS - PAPAS PREPARADAS
-- =====================================================
INSERT INTO modifier_groups (id, name, type, required, min_selections, max_selections, position) VALUES
('papas_prep_ingredients', 'Ingredientes (puedes excluir lo que no desees)', 'multiple', false, 0, 5, 29);

INSERT INTO modifier_options (id, modifier_group_id, label, price_modifier, is_default, position) VALUES
('ing_salsa_picante', 'papas_prep_ingredients', 'Salsa picante', 0.00, true, 1),
('ing_jugo_maggi', 'papas_prep_ingredients', 'Jugo maggi', 0.00, true, 2),
('ing_limon', 'papas_prep_ingredients', 'Limón', 0.00, true, 3),
('ing_rielitos', 'papas_prep_ingredients', 'Rielitos', 0.00, true, 4),
('ing_cacahuates', 'papas_prep_ingredients', 'Cacahuates', 0.00, true, 5);



-- ==========================================================================================
-- MIGRATION: 004_admin_auth_rls_policies.sql
-- ==========================================================================================

-- Helper function: Check if user is admin
CREATE OR REPLACE FUNCTION is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM admin_users
    WHERE id = auth.uid()
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function: Check if user has specific role
CREATE OR REPLACE FUNCTION has_admin_role(required_role TEXT)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM admin_users
    WHERE id = auth.uid()
    AND role = required_role
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- CATEGORIES RLS POLICIES
-- =====================================================

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Public can view active categories" ON categories;
DROP POLICY IF EXISTS "Allow public read on categories" ON categories;
DROP POLICY IF EXISTS "Allow admin full access on categories" ON categories;

-- Public can view active categories
CREATE POLICY "Public can view active categories"
  ON categories FOR SELECT
  USING (is_active = true);

-- Admins can view all categories
CREATE POLICY "Admins can view all categories"
  ON categories FOR SELECT
  USING (is_admin());

-- Admins can insert categories
CREATE POLICY "Admins can create categories"
  ON categories FOR INSERT
  WITH CHECK (is_admin());

-- Admins can update categories
CREATE POLICY "Admins can update categories"
  ON categories FOR UPDATE
  USING (is_admin())
  WITH CHECK (is_admin());

-- Admins can delete categories
CREATE POLICY "Admins can delete categories"
  ON categories FOR DELETE
  USING (is_admin());

-- =====================================================
-- MENU ITEMS RLS POLICIES
-- =====================================================

-- Drop existing policies
DROP POLICY IF EXISTS "Public can view available menu items" ON menu_items;
DROP POLICY IF EXISTS "Allow public read on menu_items" ON menu_items;
DROP POLICY IF EXISTS "Allow admin full access on menu_items" ON menu_items;

-- Public can view available items
CREATE POLICY "Public can view available menu items"
  ON menu_items FOR SELECT
  USING (is_available = true);

-- Admins can view all items
CREATE POLICY "Admins can view all menu items"
  ON menu_items FOR SELECT
  USING (is_admin());

-- Admins can insert items
CREATE POLICY "Admins can create menu items"
  ON menu_items FOR INSERT
  WITH CHECK (is_admin());

-- Admins can update items
CREATE POLICY "Admins can update menu items"
  ON menu_items FOR UPDATE
  USING (is_admin())
  WITH CHECK (is_admin());

-- Admins can delete items
CREATE POLICY "Admins can delete menu items"
  ON menu_items FOR DELETE
  USING (is_admin());

-- =====================================================
-- MODIFIER GROUPS RLS POLICIES
-- =====================================================

-- Public can view all modifier groups (needed for customization)
CREATE POLICY "Public can view modifier groups"
  ON modifier_groups FOR SELECT
  USING (true);

-- Admins can manage modifier groups
CREATE POLICY "Admins can create modifier groups"
  ON modifier_groups FOR INSERT
  WITH CHECK (is_admin());

CREATE POLICY "Admins can update modifier groups"
  ON modifier_groups FOR UPDATE
  USING (is_admin())
  WITH CHECK (is_admin());

CREATE POLICY "Admins can delete modifier groups"
  ON modifier_groups FOR DELETE
  USING (is_admin());

-- =====================================================
-- MODIFIER OPTIONS RLS POLICIES
-- =====================================================

-- Public can view all modifier options
CREATE POLICY "Public can view modifier options"
  ON modifier_options FOR SELECT
  USING (true);

-- Admins can manage modifier options
CREATE POLICY "Admins can create modifier options"
  ON modifier_options FOR INSERT
  WITH CHECK (is_admin());

CREATE POLICY "Admins can update modifier options"
  ON modifier_options FOR UPDATE
  USING (is_admin())
  WITH CHECK (is_admin());

CREATE POLICY "Admins can delete modifier options"
  ON modifier_options FOR DELETE
  USING (is_admin());

-- =====================================================
-- MENU ITEM MODIFIERS RLS POLICIES
-- =====================================================

-- Public can view linkages
CREATE POLICY "Public can view menu item modifiers"
  ON menu_item_modifiers FOR SELECT
  USING (true);

-- Admins can manage linkages
CREATE POLICY "Admins can create menu item modifiers"
  ON menu_item_modifiers FOR INSERT
  WITH CHECK (is_admin());

CREATE POLICY "Admins can update menu item modifiers"
  ON menu_item_modifiers FOR UPDATE
  USING (is_admin())
  WITH CHECK (is_admin());

CREATE POLICY "Admins can delete menu item modifiers"
  ON menu_item_modifiers FOR DELETE
  USING (is_admin());

-- =====================================================
-- ADMIN USERS RLS POLICIES
-- =====================================================

-- Admins can view all admin users
CREATE POLICY "Admins can view admin users"
  ON admin_users FOR SELECT
  USING (is_admin());

-- Only super admins (role = 'admin') can manage admin users
CREATE POLICY "Super admins can create admin users"
  ON admin_users FOR INSERT
  WITH CHECK (has_admin_role('admin'));

CREATE POLICY "Super admins can update admin users"
  ON admin_users FOR UPDATE
  USING (has_admin_role('admin'))
  WITH CHECK (has_admin_role('admin'));

CREATE POLICY "Super admins can delete admin users"
  ON admin_users FOR DELETE
  USING (has_admin_role('admin'));

-- =====================================================
-- HEADER IMAGES (PROMOTIONAL IMAGES) RLS POLICIES
-- =====================================================

-- Enable RLS on Header Images table
ALTER TABLE "Header Images" ENABLE ROW LEVEL SECURITY;

-- Public can view all header images
CREATE POLICY "Public can view header images"
  ON "Header Images" FOR SELECT
  USING (true);

-- Admins can manage header images
CREATE POLICY "Admins can create header images"
  ON "Header Images" FOR INSERT
  WITH CHECK (is_admin());

CREATE POLICY "Admins can update header images"
  ON "Header Images" FOR UPDATE
  USING (is_admin())
  WITH CHECK (is_admin());

CREATE POLICY "Admins can delete header images"
  ON "Header Images" FOR DELETE
  USING (is_admin());

-- =====================================================
-- COMMENTS & METADATA
-- =====================================================

COMMENT ON FUNCTION is_admin() IS 'Helper function to check if current user is an admin';
COMMENT ON FUNCTION has_admin_role(TEXT) IS 'Helper function to check if current user has a specific admin role';

-- =====================================================
-- REALTIME ENABLEMENT
-- =====================================================

-- Enable realtime for all tables so admin changes reflect immediately on public menu
-- Note: Run these individually in Supabase SQL Editor if needed
-- ALTER PUBLICATION supabase_realtime ADD TABLE categories;
-- ALTER PUBLICATION supabase_realtime ADD TABLE menu_items;
-- ALTER PUBLICATION supabase_realtime ADD TABLE modifier_groups;
-- ALTER PUBLICATION supabase_realtime ADD TABLE modifier_options;
-- ALTER PUBLICATION supabase_realtime ADD TABLE menu_item_modifiers;
-- ALTER PUBLICATION supabase_realtime ADD TABLE "Header Images";

-- =====================================================
-- VERIFICATION QUERIES
-- =====================================================

-- Run these to verify policies are working:
-- 1. Check if is_admin() function exists
-- SELECT proname FROM pg_proc WHERE proname = 'is_admin';

-- 2. List all policies
-- SELECT schemaname, tablename, policyname, permissive, roles, cmd, qual
-- FROM pg_policies
-- WHERE schemaname = 'public'
-- ORDER BY tablename, policyname;

-- 3. Test public access (should only see active/available items)
-- SET ROLE anon;
-- SELECT * FROM categories; -- Should only return is_active = true
-- SELECT * FROM menu_items; -- Should only return is_available = true
-- RESET ROLE;



-- ==========================================================================================
-- MIGRATION: 005_add_variants_table.sql
-- ==========================================================================================

-- Create variants table
CREATE TABLE menu_item_variants (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  menu_item_id UUID NOT NULL REFERENCES menu_items(id) ON DELETE CASCADE,
  name TEXT NOT NULL, -- Variant name (e.g., "Medium", "Grande", "Extra Grande", "Personal", etc.)
  price DECIMAL(10,2) NOT NULL CHECK (price >= 0), -- Variant price
  position INTEGER NOT NULL DEFAULT 0, -- Display order
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ,

  -- Ensure no duplicate variant names per item
  UNIQUE(menu_item_id, name)
);

-- Index for efficient lookup of variants for a menu item
CREATE INDEX idx_menu_item_variants_item ON menu_item_variants(menu_item_id, position);

-- Trigger for auto-updating updated_at
CREATE TRIGGER update_menu_item_variants_updated_at BEFORE UPDATE ON menu_item_variants
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Remove the price_check constraint from menu_items
-- Now we support three pricing models:
-- 1. Single price (price field only)
-- 2. Legacy medium/grande (price_medium + price_grande)
-- 3. New variants table (unlimited variants)
ALTER TABLE menu_items DROP CONSTRAINT IF EXISTS price_check;

-- Add new flexible constraint
-- Either: single price, OR medium+grande, OR has variants in variants table
ALTER TABLE menu_items ADD CONSTRAINT price_check_flexible CHECK (
  (price IS NOT NULL AND price_medium IS NULL AND price_grande IS NULL) OR
  (price IS NULL AND price_medium IS NOT NULL AND price_grande IS NOT NULL) OR
  (price IS NULL AND price_medium IS NULL AND price_grande IS NULL)
);

-- Add comment
COMMENT ON TABLE menu_item_variants IS 'Unlimited size variants for menu items (e.g., Small, Medium, Large, Extra Large, etc.)';
COMMENT ON COLUMN menu_item_variants.name IS 'Variant name (e.g., "Medium", "Grande", "Extra Grande", "Personal")';
COMMENT ON COLUMN menu_item_variants.price IS 'Price for this specific variant';
COMMENT ON COLUMN menu_item_variants.position IS 'Display order (0-based, lower numbers appear first)';



-- ==========================================================================================
-- MIGRATION: 006_add_menu_item_ingredients_table.sql
-- ==========================================================================================

-- Create menu_item_ingredients table
CREATE TABLE IF NOT EXISTS menu_item_ingredients (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  menu_item_id UUID NOT NULL REFERENCES menu_items(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  can_exclude BOOLEAN NOT NULL DEFAULT true,
  position INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ,
  UNIQUE(menu_item_id, name)
);

-- Add index for faster queries
CREATE INDEX IF NOT EXISTS idx_menu_item_ingredients_menu_item_id
  ON menu_item_ingredients(menu_item_id);

-- Add updated_at trigger
CREATE TRIGGER set_menu_item_ingredients_updated_at
  BEFORE UPDATE ON menu_item_ingredients
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Add RLS policies
ALTER TABLE menu_item_ingredients ENABLE ROW LEVEL SECURITY;

-- Public can read ingredients for available menu items
CREATE POLICY "Allow public read access to ingredients"
  ON menu_item_ingredients
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM menu_items
      WHERE menu_items.id = menu_item_ingredients.menu_item_id
      AND menu_items.is_available = true
    )
  );

-- Admin users can do everything with ingredients
CREATE POLICY "Allow admin full access to ingredients"
  ON menu_item_ingredients
  FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM admin_users
      WHERE admin_users.id = auth.uid()
    )
  );



-- ==========================================================================================
-- MIGRATION: 007_create_promotional_images.sql
-- ==========================================================================================

-- Create promotional_images table
CREATE TABLE IF NOT EXISTS promotional_images (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  -- Image information
  image_url TEXT NOT NULL,
  title TEXT,
  description TEXT,

  -- Optional features
  link_url TEXT, -- Link to menu item or external URL
  link_menu_item_id UUID REFERENCES menu_items(id) ON DELETE SET NULL,

  -- Display control
  position INTEGER NOT NULL DEFAULT 0,
  is_active BOOLEAN NOT NULL DEFAULT true,

  -- Scheduling (optional)
  start_date TIMESTAMPTZ,
  end_date TIMESTAMPTZ,

  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ,

  -- Constraints
  CONSTRAINT check_dates CHECK (
    (start_date IS NULL OR end_date IS NULL) OR
    (start_date < end_date)
  )
);

-- Index for active promotions ordered by position
CREATE INDEX idx_promotional_images_active ON promotional_images(is_active, position)
  WHERE is_active = true;

-- Index for scheduled promotions
CREATE INDEX idx_promotional_images_schedule ON promotional_images(start_date, end_date)
  WHERE start_date IS NOT NULL OR end_date IS NOT NULL;

-- Auto-update updated_at timestamp
CREATE TRIGGER update_promotional_images_updated_at
  BEFORE UPDATE ON promotional_images
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Add comment
COMMENT ON TABLE promotional_images IS 'Promotional banner/carousel images for the menu homepage';
COMMENT ON COLUMN promotional_images.link_menu_item_id IS 'Optional link to a specific menu item';
COMMENT ON COLUMN promotional_images.position IS 'Display order in carousel (lower numbers appear first)';

-- =====================================================
-- MIGRATE DATA FROM OLD "Header Images" TABLE
-- =====================================================

-- Only run if old table exists
DO $$
BEGIN
  IF EXISTS (
    SELECT FROM information_schema.tables
    WHERE table_name = 'Header Images'
  ) THEN
    -- Migrate existing data
    INSERT INTO promotional_images (image_url, position, is_active, created_at)
    SELECT
      "Image url" as image_url,
      ROW_NUMBER() OVER (ORDER BY created_at) - 1 as position,
      COALESCE(is_active, true) as is_active,
      created_at
    FROM "Header Images"
    ON CONFLICT DO NOTHING;

    -- Log migration
    RAISE NOTICE 'Migrated % rows from "Header Images" to promotional_images',
      (SELECT COUNT(*) FROM "Header Images");
  ELSE
    RAISE NOTICE '"Header Images" table does not exist, skipping migration';
  END IF;
END $$;

-- =====================================================
-- ROW LEVEL SECURITY (RLS)
-- =====================================================

-- Enable RLS
ALTER TABLE promotional_images ENABLE ROW LEVEL SECURITY;

-- Public can view active promotions that are currently scheduled
CREATE POLICY "Public can view active promotions"
  ON promotional_images
  FOR SELECT
  USING (
    is_active = true AND
    (start_date IS NULL OR start_date <= NOW()) AND
    (end_date IS NULL OR end_date >= NOW())
  );

-- Admins can view all promotions
CREATE POLICY "Admins can view all promotions"
  ON promotional_images
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM admin_users
      WHERE id = auth.uid()
    )
  );

-- Admins can insert promotions
CREATE POLICY "Admins can create promotions"
  ON promotional_images
  FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM admin_users
      WHERE id = auth.uid()
    )
  );

-- Admins can update promotions
CREATE POLICY "Admins can update promotions"
  ON promotional_images
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM admin_users
      WHERE id = auth.uid()
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM admin_users
      WHERE id = auth.uid()
    )
  );

-- Admins can delete promotions
CREATE POLICY "Admins can delete promotions"
  ON promotional_images
  FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM admin_users
      WHERE id = auth.uid()
    )
  );

-- =====================================================
-- STORAGE BUCKET SETUP INSTRUCTIONS
-- =====================================================

-- Run these commands in Supabase Dashboard > Storage:
-- 1. Create bucket named "promotional-images" with public access
-- 2. Set max file size to 5MB
-- 3. Allowed file types: image/jpeg, image/png, image/webp

-- Storage policies will need to be set up in the Supabase dashboard:
-- Policy 1: Public can view images
--   SELECT on storage.objects where bucket_id = 'promotional-images'
--
-- Policy 2: Admins can upload images
--   INSERT on storage.objects where bucket_id = 'promotional-images'
--   and auth.uid() IN (SELECT id FROM admin_users)
--
-- Policy 3: Admins can update/delete images
--   UPDATE/DELETE on storage.objects where bucket_id = 'promotional-images'
--   and auth.uid() IN (SELECT id FROM admin_users)



-- ==========================================================================================
-- MIGRATION: 20250114_001_create_restaurants_table.sql
-- ==========================================================================================

-- Create restaurants table
CREATE TABLE IF NOT EXISTS public.restaurants (
    -- Primary Key
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Restaurant Identity
    restaurant_name TEXT NOT NULL,
    business_name TEXT, -- Legal business name if different

    -- Multi-tenant URL Strategy
    subdomain TEXT UNIQUE NOT NULL, -- e.g., "elysium" for elysium.yourplatform.com
    custom_domain TEXT UNIQUE, -- e.g., "menu.elysiumrestaurant.com" (optional)

    -- Subscription & Billing
    subscription_tier TEXT NOT NULL DEFAULT 'trial' CHECK (subscription_tier IN ('trial', 'basic', 'professional', 'enterprise')),
    subscription_status TEXT NOT NULL DEFAULT 'active' CHECK (subscription_status IN ('active', 'inactive', 'suspended', 'cancelled')),
    subscription_start_date TIMESTAMPTZ,
    subscription_end_date TIMESTAMPTZ,
    billing_email TEXT,

    -- Restaurant Details
    description TEXT,
    cuisine_type TEXT[], -- Array of cuisine types, e.g., ["Japanese", "Sushi"]
    phone TEXT,
    email TEXT,
    website TEXT,

    -- Location Information
    address_line1 TEXT,
    address_line2 TEXT,
    city TEXT,
    state TEXT,
    postal_code TEXT,
    country TEXT DEFAULT 'Mexico',
    timezone TEXT DEFAULT 'America/Mexico_City',

    -- Operating Hours (JSON structure for flexibility)
    operating_hours JSONB DEFAULT '{
        "monday": {"open": "09:00", "close": "22:00", "closed": false},
        "tuesday": {"open": "09:00", "close": "22:00", "closed": false},
        "wednesday": {"open": "09:00", "close": "22:00", "closed": false},
        "thursday": {"open": "09:00", "close": "22:00", "closed": false},
        "friday": {"open": "09:00", "close": "23:00", "closed": false},
        "saturday": {"open": "09:00", "close": "23:00", "closed": false},
        "sunday": {"open": "10:00", "close": "21:00", "closed": false}
    }'::jsonb,

    -- Branding & Customization
    logo_url TEXT,
    primary_color TEXT DEFAULT '#B0C4DE', -- Steel blue default
    secondary_color TEXT,
    banner_image_url TEXT,

    -- Platform Settings
    is_active BOOLEAN NOT NULL DEFAULT true,
    is_verified BOOLEAN NOT NULL DEFAULT false, -- Email/business verification
    onboarding_completed BOOLEAN NOT NULL DEFAULT false,

    -- Features & Limits (based on subscription tier)
    features JSONB DEFAULT '{
        "max_menu_items": 100,
        "max_categories": 20,
        "max_modifiers": 50,
        "max_admin_users": 3,
        "custom_domain": false,
        "analytics": false,
        "api_access": false,
        "white_label": false,
        "priority_support": false
    }'::jsonb,

    -- Usage Tracking
    total_menu_items INTEGER DEFAULT 0,
    total_categories INTEGER DEFAULT 0,
    total_admin_users INTEGER DEFAULT 0,

    -- Metadata
    metadata JSONB DEFAULT '{}'::jsonb, -- Extensible field for custom data

    -- Audit Fields
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted_at TIMESTAMPTZ, -- Soft delete support

    -- Constraints
    CONSTRAINT valid_subdomain CHECK (
        subdomain ~ '^[a-z0-9][a-z0-9-]{1,61}[a-z0-9]$' -- Valid subdomain pattern
    ),
    CONSTRAINT valid_subscription_dates CHECK (
        subscription_end_date IS NULL OR subscription_end_date > subscription_start_date
    )
);

-- Create indexes for performance
CREATE INDEX idx_restaurants_subdomain ON public.restaurants(subdomain) WHERE deleted_at IS NULL;
CREATE INDEX idx_restaurants_custom_domain ON public.restaurants(custom_domain) WHERE custom_domain IS NOT NULL AND deleted_at IS NULL;
CREATE INDEX idx_restaurants_subscription_status ON public.restaurants(subscription_status, subscription_tier) WHERE deleted_at IS NULL;
CREATE INDEX idx_restaurants_is_active ON public.restaurants(is_active) WHERE deleted_at IS NULL;
CREATE INDEX idx_restaurants_created_at ON public.restaurants(created_at DESC);

-- Create updated_at trigger
CREATE OR REPLACE FUNCTION update_restaurants_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER restaurants_updated_at
    BEFORE UPDATE ON public.restaurants
    FOR EACH ROW
    EXECUTE FUNCTION update_restaurants_updated_at();

-- =====================================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- =====================================================

-- Enable RLS
ALTER TABLE public.restaurants ENABLE ROW LEVEL SECURITY;

-- Policy: Public can view active restaurants (for public menu access)
-- This allows fetching restaurant info by subdomain/domain without auth
CREATE POLICY "public_view_active_restaurants"
    ON public.restaurants
    FOR SELECT
    USING (
        is_active = true
        AND deleted_at IS NULL
        AND subscription_status = 'active'
    );

-- Policy: Super admins can view all restaurants
-- Note: We'll need to add a super_admin flag to admin_users in the next migration
CREATE POLICY "super_admin_view_all_restaurants"
    ON public.restaurants
    FOR SELECT
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND admin_users.role = 'super_admin'
        )
    );

-- Policy: Restaurant admins can view their own restaurant
CREATE POLICY "restaurant_admin_view_own"
    ON public.restaurants
    FOR SELECT
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND admin_users.restaurant_id = restaurants.id
        )
    );

-- Policy: Super admins can create restaurants
CREATE POLICY "super_admin_create_restaurants"
    ON public.restaurants
    FOR INSERT
    TO authenticated
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND admin_users.role = 'super_admin'
        )
    );

-- Policy: Super admins can update any restaurant
CREATE POLICY "super_admin_update_any_restaurant"
    ON public.restaurants
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND admin_users.role = 'super_admin'
        )
    );

-- Policy: Restaurant admins can update their own restaurant (limited fields)
CREATE POLICY "restaurant_admin_update_own"
    ON public.restaurants
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND admin_users.restaurant_id = restaurants.id
            AND admin_users.role IN ('admin', 'manager')
        )
    )
    WITH CHECK (
        -- Prevent restaurant admins from modifying sensitive fields
        (NEW.subscription_tier = OLD.subscription_tier)
        AND (NEW.subscription_status = OLD.subscription_status)
        AND (NEW.features = OLD.features)
        AND (NEW.is_verified = OLD.is_verified)
    );

-- Policy: Only super admins can delete (soft delete) restaurants
CREATE POLICY "super_admin_delete_restaurants"
    ON public.restaurants
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND admin_users.role = 'super_admin'
        )
    )
    WITH CHECK (deleted_at IS NOT NULL);

-- =====================================================
-- HELPER FUNCTIONS
-- =====================================================

-- Function to get restaurant by subdomain
CREATE OR REPLACE FUNCTION get_restaurant_by_subdomain(p_subdomain TEXT)
RETURNS TABLE (
    id UUID,
    restaurant_name TEXT,
    subdomain TEXT,
    custom_domain TEXT,
    is_active BOOLEAN,
    subscription_status TEXT,
    primary_color TEXT,
    logo_url TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        r.id,
        r.restaurant_name,
        r.subdomain,
        r.custom_domain,
        r.is_active,
        r.subscription_status,
        r.primary_color,
        r.logo_url
    FROM public.restaurants r
    WHERE
        (r.subdomain = p_subdomain OR r.custom_domain = p_subdomain)
        AND r.deleted_at IS NULL
        AND r.is_active = true
        AND r.subscription_status = 'active';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check subscription limits
CREATE OR REPLACE FUNCTION check_restaurant_limit(
    p_restaurant_id UUID,
    p_limit_type TEXT
) RETURNS BOOLEAN AS $$
DECLARE
    v_current_count INTEGER;
    v_max_allowed INTEGER;
BEGIN
    -- Get the max allowed from features
    SELECT (features->>('max_' || p_limit_type))::INTEGER
    INTO v_max_allowed
    FROM public.restaurants
    WHERE id = p_restaurant_id;

    -- Get current count based on limit type
    CASE p_limit_type
        WHEN 'menu_items' THEN
            SELECT COUNT(*) INTO v_current_count
            FROM public.menu_items
            WHERE restaurant_id = p_restaurant_id;
        WHEN 'categories' THEN
            SELECT COUNT(*) INTO v_current_count
            FROM public.categories
            WHERE restaurant_id = p_restaurant_id;
        WHEN 'admin_users' THEN
            SELECT COUNT(*) INTO v_current_count
            FROM public.admin_users
            WHERE restaurant_id = p_restaurant_id;
        ELSE
            RETURN true; -- Unknown limit type, allow by default
    END CASE;

    RETURN v_current_count < v_max_allowed;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE public.restaurants IS 'Core table for multi-tenant restaurant management. Each restaurant is a separate tenant with isolated data.';
COMMENT ON COLUMN public.restaurants.subdomain IS 'Unique subdomain for restaurant access (e.g., elysium.yourplatform.com)';
COMMENT ON COLUMN public.restaurants.custom_domain IS 'Optional custom domain (e.g., menu.restaurant.com) - Enterprise feature';
COMMENT ON COLUMN public.restaurants.subscription_tier IS 'trial | basic | professional | enterprise - Determines feature access and limits';
COMMENT ON COLUMN public.restaurants.features IS 'JSON object containing feature flags and limits based on subscription tier';
COMMENT ON COLUMN public.restaurants.operating_hours IS 'JSON object with daily operating hours in restaurant timezone';
COMMENT ON COLUMN public.restaurants.deleted_at IS 'Soft delete timestamp. Non-null values indicate deleted restaurants (data retained for recovery)';

-- =====================================================
-- SUCCESS MESSAGE
-- =====================================================

DO $$
BEGIN
    RAISE NOTICE '✅ Migration 20250114_001_create_restaurants_table.sql completed successfully';
    RAISE NOTICE '📋 Created restaurants table with comprehensive multi-tenant support';
    RAISE NOTICE '🔒 Applied RLS policies for secure multi-tenant data access';
    RAISE NOTICE '⚡ Created indexes for optimal query performance';
    RAISE NOTICE '🔧 Created helper functions for common restaurant operations';
END $$;



-- ==========================================================================================
-- MIGRATION: 20250114_002_add_restaurant_id_to_tables.sql
-- ==========================================================================================

-- =====================================================
-- STEP 1: Update admin_users table
-- =====================================================

-- Add restaurant_id and super_admin support to admin_users
ALTER TABLE public.admin_users
    ADD COLUMN restaurant_id UUID REFERENCES public.restaurants(id) ON DELETE CASCADE,
    ADD COLUMN is_super_admin BOOLEAN NOT NULL DEFAULT false;

-- Update role check constraint to include super_admin
ALTER TABLE public.admin_users
    DROP CONSTRAINT IF EXISTS admin_users_role_check;

ALTER TABLE public.admin_users
    ADD CONSTRAINT admin_users_role_check
    CHECK (role IN ('super_admin', 'admin', 'manager', 'editor'));

-- Create index for restaurant-based queries
CREATE INDEX idx_admin_users_restaurant_id ON public.admin_users(restaurant_id) WHERE restaurant_id IS NOT NULL;
CREATE INDEX idx_admin_users_super_admin ON public.admin_users(is_super_admin) WHERE is_super_admin = true;

COMMENT ON COLUMN public.admin_users.restaurant_id IS 'Links admin user to a specific restaurant. NULL for super_admins who can access all restaurants';
COMMENT ON COLUMN public.admin_users.is_super_admin IS 'Platform super admin flag. Super admins can manage all restaurants and have full system access';

-- =====================================================
-- STEP 2: Add restaurant_id to categories table
-- =====================================================

ALTER TABLE public.categories
    ADD COLUMN restaurant_id UUID REFERENCES public.restaurants(id) ON DELETE CASCADE;

-- Create index for tenant-specific queries
CREATE INDEX idx_categories_restaurant_id ON public.categories(restaurant_id, position);
CREATE INDEX idx_categories_restaurant_active ON public.categories(restaurant_id, is_active);

-- Update unique constraint to be per-restaurant
ALTER TABLE public.categories
    DROP CONSTRAINT IF EXISTS categories_name_key;

CREATE UNIQUE INDEX idx_categories_name_per_restaurant
    ON public.categories(restaurant_id, LOWER(name))
    WHERE restaurant_id IS NOT NULL;

COMMENT ON COLUMN public.categories.restaurant_id IS 'Links category to a specific restaurant for multi-tenant data isolation';

-- =====================================================
-- STEP 3: Add restaurant_id to menu_items table
-- =====================================================

ALTER TABLE public.menu_items
    ADD COLUMN restaurant_id UUID REFERENCES public.restaurants(id) ON DELETE CASCADE;

-- Create indexes for tenant-specific queries
CREATE INDEX idx_menu_items_restaurant_id ON public.menu_items(restaurant_id, category_id);
CREATE INDEX idx_menu_items_restaurant_available ON public.menu_items(restaurant_id, is_available);
CREATE INDEX idx_menu_items_restaurant_position ON public.menu_items(restaurant_id, category_id, position);

COMMENT ON COLUMN public.menu_items.restaurant_id IS 'Links menu item to a specific restaurant for multi-tenant data isolation';

-- =====================================================
-- STEP 4: Add restaurant_id to modifier_groups table
-- =====================================================

ALTER TABLE public.modifier_groups
    ADD COLUMN restaurant_id UUID REFERENCES public.restaurants(id) ON DELETE CASCADE;

-- Create index for tenant-specific queries
CREATE INDEX idx_modifier_groups_restaurant_id ON public.modifier_groups(restaurant_id, position);

-- Update unique constraint to be per-restaurant (id is TEXT, so it should be unique per restaurant)
CREATE UNIQUE INDEX idx_modifier_groups_id_per_restaurant
    ON public.modifier_groups(restaurant_id, id)
    WHERE restaurant_id IS NOT NULL;

COMMENT ON COLUMN public.modifier_groups.restaurant_id IS 'Links modifier group to a specific restaurant for multi-tenant data isolation';

-- =====================================================
-- STEP 5: Add restaurant_id to modifier_options table
-- =====================================================

ALTER TABLE public.modifier_options
    ADD COLUMN restaurant_id UUID REFERENCES public.restaurants(id) ON DELETE CASCADE;

-- Create index for tenant-specific queries
CREATE INDEX idx_modifier_options_restaurant_id ON public.modifier_options(restaurant_id, modifier_group_id);

-- Update unique constraint to be per-restaurant
CREATE UNIQUE INDEX idx_modifier_options_id_per_restaurant
    ON public.modifier_options(restaurant_id, id)
    WHERE restaurant_id IS NOT NULL;

COMMENT ON COLUMN public.modifier_options.restaurant_id IS 'Links modifier option to a specific restaurant for multi-tenant data isolation';

-- =====================================================
-- STEP 6: Add restaurant_id to menu_item_modifiers table
-- =====================================================

ALTER TABLE public.menu_item_modifiers
    ADD COLUMN restaurant_id UUID REFERENCES public.restaurants(id) ON DELETE CASCADE;

-- Create index for tenant-specific queries
CREATE INDEX idx_menu_item_modifiers_restaurant_id ON public.menu_item_modifiers(restaurant_id, menu_item_id);

COMMENT ON COLUMN public.menu_item_modifiers.restaurant_id IS 'Links menu item modifier association to a specific restaurant for multi-tenant data isolation';

-- =====================================================
-- STEP 7: Add restaurant_id to menu_item_variants table
-- =====================================================

ALTER TABLE public.menu_item_variants
    ADD COLUMN restaurant_id UUID REFERENCES public.restaurants(id) ON DELETE CASCADE;

-- Create index for tenant-specific queries
CREATE INDEX idx_menu_item_variants_restaurant_id ON public.menu_item_variants(restaurant_id, menu_item_id);

COMMENT ON COLUMN public.menu_item_variants.restaurant_id IS 'Links menu item variant to a specific restaurant for multi-tenant data isolation';

-- =====================================================
-- STEP 8: Add restaurant_id to menu_item_ingredients table
-- =====================================================

ALTER TABLE public.menu_item_ingredients
    ADD COLUMN restaurant_id UUID REFERENCES public.restaurants(id) ON DELETE CASCADE;

-- Create index for tenant-specific queries
CREATE INDEX idx_menu_item_ingredients_restaurant_id ON public.menu_item_ingredients(restaurant_id, menu_item_id);

COMMENT ON COLUMN public.menu_item_ingredients.restaurant_id IS 'Links menu item ingredient to a specific restaurant for multi-tenant data isolation';

-- =====================================================
-- STEP 9: Add restaurant_id to promotional_images table
-- =====================================================

ALTER TABLE public.promotional_images
    ADD COLUMN restaurant_id UUID REFERENCES public.restaurants(id) ON DELETE CASCADE;

-- Create indexes for tenant-specific queries
CREATE INDEX idx_promotional_images_restaurant_id ON public.promotional_images(restaurant_id, position);
CREATE INDEX idx_promotional_images_restaurant_active ON public.promotional_images(restaurant_id, is_active);

COMMENT ON COLUMN public.promotional_images.restaurant_id IS 'Links promotional image to a specific restaurant for multi-tenant data isolation';

-- =====================================================
-- STEP 10: Create function to sync restaurant_id across related tables
-- =====================================================

-- This function ensures that when a menu_item's restaurant_id is set,
-- all its related records (variants, ingredients, modifiers) inherit the same restaurant_id
CREATE OR REPLACE FUNCTION sync_menu_item_restaurant_id()
RETURNS TRIGGER AS $$
BEGIN
    -- Update variants
    UPDATE public.menu_item_variants
    SET restaurant_id = NEW.restaurant_id
    WHERE menu_item_id = NEW.id
    AND (restaurant_id IS NULL OR restaurant_id != NEW.restaurant_id);

    -- Update ingredients
    UPDATE public.menu_item_ingredients
    SET restaurant_id = NEW.restaurant_id
    WHERE menu_item_id = NEW.id
    AND (restaurant_id IS NULL OR restaurant_id != NEW.restaurant_id);

    -- Update menu_item_modifiers associations
    UPDATE public.menu_item_modifiers
    SET restaurant_id = NEW.restaurant_id
    WHERE menu_item_id = NEW.id
    AND (restaurant_id IS NULL OR restaurant_id != NEW.restaurant_id);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sync_menu_item_restaurant_id_trigger
    AFTER INSERT OR UPDATE OF restaurant_id ON public.menu_items
    FOR EACH ROW
    WHEN (NEW.restaurant_id IS NOT NULL)
    EXECUTE FUNCTION sync_menu_item_restaurant_id();

-- =====================================================
-- STEP 11: Create function to validate restaurant_id consistency
-- =====================================================

-- Ensures that menu_items can only reference categories from the same restaurant
CREATE OR REPLACE FUNCTION validate_menu_item_category_restaurant()
RETURNS TRIGGER AS $$
DECLARE
    v_category_restaurant_id UUID;
BEGIN
    -- Get the category's restaurant_id
    SELECT restaurant_id INTO v_category_restaurant_id
    FROM public.categories
    WHERE id = NEW.category_id;

    -- Check if restaurant_ids match
    IF v_category_restaurant_id IS DISTINCT FROM NEW.restaurant_id THEN
        RAISE EXCEPTION 'Menu item restaurant_id (%) must match category restaurant_id (%)',
            NEW.restaurant_id, v_category_restaurant_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validate_menu_item_category_restaurant_trigger
    BEFORE INSERT OR UPDATE OF restaurant_id, category_id ON public.menu_items
    FOR EACH ROW
    WHEN (NEW.restaurant_id IS NOT NULL AND NEW.category_id IS NOT NULL)
    EXECUTE FUNCTION validate_menu_item_category_restaurant();

-- Ensures that modifier_options can only reference modifier_groups from the same restaurant
CREATE OR REPLACE FUNCTION validate_modifier_option_group_restaurant()
RETURNS TRIGGER AS $$
DECLARE
    v_group_restaurant_id UUID;
BEGIN
    -- Get the modifier_group's restaurant_id
    SELECT restaurant_id INTO v_group_restaurant_id
    FROM public.modifier_groups
    WHERE id = NEW.modifier_group_id;

    -- Check if restaurant_ids match
    IF v_group_restaurant_id IS DISTINCT FROM NEW.restaurant_id THEN
        RAISE EXCEPTION 'Modifier option restaurant_id (%) must match modifier group restaurant_id (%)',
            NEW.restaurant_id, v_group_restaurant_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validate_modifier_option_group_restaurant_trigger
    BEFORE INSERT OR UPDATE OF restaurant_id, modifier_group_id ON public.modifier_options
    FOR EACH ROW
    WHEN (NEW.restaurant_id IS NOT NULL AND NEW.modifier_group_id IS NOT NULL)
    EXECUTE FUNCTION validate_modifier_option_group_restaurant();

-- =====================================================
-- STEP 12: Create helper function to get current restaurant context
-- =====================================================

-- This function retrieves the restaurant_id for the current authenticated user
-- Super admins need to explicitly pass restaurant_id, others get their assigned restaurant
CREATE OR REPLACE FUNCTION get_user_restaurant_id()
RETURNS UUID AS $$
DECLARE
    v_restaurant_id UUID;
    v_is_super_admin BOOLEAN;
BEGIN
    -- Get user's restaurant_id and super_admin status
    SELECT restaurant_id, is_super_admin
    INTO v_restaurant_id, v_is_super_admin
    FROM public.admin_users
    WHERE id = auth.uid();

    -- Super admins don't have a default restaurant_id
    -- They need to explicitly specify which restaurant they're working with
    IF v_is_super_admin THEN
        RETURN NULL; -- Super admin must explicitly set restaurant context
    END IF;

    RETURN v_restaurant_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION get_user_restaurant_id() IS 'Returns the restaurant_id for the current authenticated user. Returns NULL for super_admins who must explicitly set restaurant context.';

-- =====================================================
-- STEP 13: Create function to set restaurant context (for super admins)
-- =====================================================

-- Super admins can temporarily set their restaurant context for operations
-- This is stored in a config setting for the current session
CREATE OR REPLACE FUNCTION set_restaurant_context(p_restaurant_id UUID)
RETURNS VOID AS $$
BEGIN
    -- Verify user is a super admin
    IF NOT EXISTS (
        SELECT 1 FROM public.admin_users
        WHERE id = auth.uid()
        AND is_super_admin = true
    ) THEN
        RAISE EXCEPTION 'Only super admins can set restaurant context';
    END IF;

    -- Set the restaurant context for this session
    PERFORM set_config('app.current_restaurant_id', p_restaurant_id::TEXT, false);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get the current restaurant context (for super admins)
CREATE OR REPLACE FUNCTION get_restaurant_context()
RETURNS UUID AS $$
BEGIN
    -- Try to get from session config first (super admin context)
    DECLARE
        v_context_restaurant_id TEXT;
    BEGIN
        v_context_restaurant_id := current_setting('app.current_restaurant_id', true);
        IF v_context_restaurant_id IS NOT NULL THEN
            RETURN v_context_restaurant_id::UUID;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            -- Setting doesn't exist, continue
    END;

    -- Fall back to user's assigned restaurant
    RETURN get_user_restaurant_id();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION set_restaurant_context(UUID) IS 'Allows super admins to set which restaurant they are currently managing in their session';
COMMENT ON FUNCTION get_restaurant_context() IS 'Returns the current restaurant context - either from session (super admin) or user assignment';

-- =====================================================
-- SUCCESS MESSAGE
-- =====================================================

DO $$
BEGIN
    RAISE NOTICE '✅ Migration 20250114_002_add_restaurant_id_to_tables.sql completed successfully';
    RAISE NOTICE '📋 Added restaurant_id column to all tenant-specific tables:';
    RAISE NOTICE '   - admin_users (with super_admin support)';
    RAISE NOTICE '   - categories';
    RAISE NOTICE '   - menu_items';
    RAISE NOTICE '   - modifier_groups';
    RAISE NOTICE '   - modifier_options';
    RAISE NOTICE '   - menu_item_modifiers';
    RAISE NOTICE '   - menu_item_variants';
    RAISE NOTICE '   - menu_item_ingredients';
    RAISE NOTICE '   - promotional_images';
    RAISE NOTICE '⚡ Created indexes for optimal tenant-specific queries';
    RAISE NOTICE '🔧 Created triggers for automatic restaurant_id syncing';
    RAISE NOTICE '✅ Created validation triggers for referential integrity';
    RAISE NOTICE '🔒 Created context management functions for super admin operations';
END $$;



-- ==========================================================================================
-- MIGRATION: 20250114_003_update_rls_policies_multi_tenant.sql
-- ==========================================================================================

-- =====================================================
-- STEP 1: Drop existing RLS policies
-- =====================================================

-- admin_users policies
DROP POLICY IF EXISTS "admin_full_access" ON public.admin_users;
DROP POLICY IF EXISTS "manager_editor_view_only" ON public.admin_users;
DROP POLICY IF EXISTS "all_admin_update_last_login" ON public.admin_users;

-- categories policies
DROP POLICY IF EXISTS "public_view_active_categories" ON public.categories;
DROP POLICY IF EXISTS "admin_full_access_categories" ON public.categories;

-- menu_items policies
DROP POLICY IF EXISTS "public_view_available_items" ON public.menu_items;
DROP POLICY IF EXISTS "admin_full_access_menu_items" ON public.menu_items;

-- modifier_groups policies
DROP POLICY IF EXISTS "public_view_modifier_groups" ON public.modifier_groups;
DROP POLICY IF EXISTS "admin_full_access_modifier_groups" ON public.modifier_groups;

-- modifier_options policies
DROP POLICY IF EXISTS "public_view_modifier_options" ON public.modifier_options;
DROP POLICY IF EXISTS "admin_full_access_modifier_options" ON public.modifier_options;

-- menu_item_modifiers policies
DROP POLICY IF EXISTS "public_view_menu_item_modifiers" ON public.menu_item_modifiers;
DROP POLICY IF EXISTS "admin_full_access_menu_item_modifiers" ON public.menu_item_modifiers;

-- menu_item_variants policies (if they exist)
DROP POLICY IF EXISTS "public_view_menu_item_variants" ON public.menu_item_variants;
DROP POLICY IF EXISTS "admin_full_access_menu_item_variants" ON public.menu_item_variants;

-- menu_item_ingredients policies
DROP POLICY IF EXISTS "public_view_menu_item_ingredients" ON public.menu_item_ingredients;
DROP POLICY IF EXISTS "admin_full_access_menu_item_ingredients" ON public.menu_item_ingredients;

-- promotional_images policies
DROP POLICY IF EXISTS "public_view_active_promotions" ON public.promotional_images;
DROP POLICY IF EXISTS "admin_full_access_promotional_images" ON public.promotional_images;

-- =====================================================
-- STEP 2: admin_users - Tenant-Aware Policies
-- =====================================================

-- Super admins can view all admin users across all restaurants
CREATE POLICY "super_admin_view_all_users"
    ON public.admin_users
    FOR SELECT
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users self
            WHERE self.id = auth.uid()
            AND self.is_super_admin = true
        )
    );

-- Restaurant admins can view users from their own restaurant
CREATE POLICY "restaurant_admin_view_own_users"
    ON public.admin_users
    FOR SELECT
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users self
            WHERE self.id = auth.uid()
            AND self.restaurant_id = admin_users.restaurant_id
            AND self.role IN ('admin', 'manager')
        )
    );

-- Super admins can create users for any restaurant
CREATE POLICY "super_admin_create_users"
    ON public.admin_users
    FOR INSERT
    TO authenticated
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.admin_users self
            WHERE self.id = auth.uid()
            AND self.is_super_admin = true
        )
    );

-- Restaurant admins can create users for their own restaurant
CREATE POLICY "restaurant_admin_create_users"
    ON public.admin_users
    FOR INSERT
    TO authenticated
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.admin_users self
            WHERE self.id = auth.uid()
            AND self.restaurant_id = admin_users.restaurant_id
            AND self.role = 'admin'
        )
    );

-- Super admins can update any user
CREATE POLICY "super_admin_update_users"
    ON public.admin_users
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users self
            WHERE self.id = auth.uid()
            AND self.is_super_admin = true
        )
    );

-- Restaurant admins can update users in their restaurant (except other admins)
CREATE POLICY "restaurant_admin_update_users"
    ON public.admin_users
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users self
            WHERE self.id = auth.uid()
            AND self.restaurant_id = admin_users.restaurant_id
            AND self.role = 'admin'
            AND admin_users.role != 'admin' -- Can't update other admins
        )
    );

-- All admin users can update their own last_login
CREATE POLICY "all_users_update_own_last_login"
    ON public.admin_users
    FOR UPDATE
    TO authenticated
    USING (id = auth.uid())
    WITH CHECK (
        id = auth.uid()
        AND (OLD.last_login IS DISTINCT FROM NEW.last_login)
        -- Ensure no other fields are modified
        AND OLD.email = NEW.email
        AND OLD.role = NEW.role
        AND OLD.restaurant_id = NEW.restaurant_id
    );

-- Super admins can delete users
CREATE POLICY "super_admin_delete_users"
    ON public.admin_users
    FOR DELETE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users self
            WHERE self.id = auth.uid()
            AND self.is_super_admin = true
        )
    );

-- Restaurant admins can delete non-admin users from their restaurant
CREATE POLICY "restaurant_admin_delete_users"
    ON public.admin_users
    FOR DELETE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users self
            WHERE self.id = auth.uid()
            AND self.restaurant_id = admin_users.restaurant_id
            AND self.role = 'admin'
            AND admin_users.role != 'admin'
        )
    );

-- =====================================================
-- STEP 3: categories - Tenant-Aware Policies
-- =====================================================

-- Public can view active categories for any restaurant (needed for public menu)
CREATE POLICY "public_view_active_categories"
    ON public.categories
    FOR SELECT
    USING (is_active = true);

-- Admins can view categories from their restaurant or all (if super admin)
CREATE POLICY "admin_view_categories"
    ON public.categories
    FOR SELECT
    TO authenticated
    USING (
        -- Super admin can see all
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND admin_users.is_super_admin = true
        )
        OR
        -- Restaurant admin/staff can see their own
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND admin_users.restaurant_id = categories.restaurant_id
        )
    );

-- Admins can create categories for their restaurant
CREATE POLICY "admin_create_categories"
    ON public.categories
    FOR INSERT
    TO authenticated
    WITH CHECK (
        -- Super admin can create for any restaurant
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND admin_users.is_super_admin = true
        )
        OR
        -- Restaurant admin can create for their restaurant
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND admin_users.restaurant_id = categories.restaurant_id
            AND admin_users.role IN ('admin', 'manager', 'editor')
        )
    );

-- Admins can update categories in their restaurant
CREATE POLICY "admin_update_categories"
    ON public.categories
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = categories.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can delete categories from their restaurant
CREATE POLICY "admin_delete_categories"
    ON public.categories
    FOR DELETE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = categories.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager')
        )
    );

-- =====================================================
-- STEP 4: menu_items - Tenant-Aware Policies
-- =====================================================

-- Public can view available menu items for any restaurant
CREATE POLICY "public_view_available_items"
    ON public.menu_items
    FOR SELECT
    USING (is_available = true);

-- Admins can view menu items from their restaurant or all (if super admin)
CREATE POLICY "admin_view_menu_items"
    ON public.menu_items
    FOR SELECT
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_items.restaurant_id
            )
        )
    );

-- Admins can create menu items for their restaurant
CREATE POLICY "admin_create_menu_items"
    ON public.menu_items
    FOR INSERT
    TO authenticated
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_items.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can update menu items in their restaurant
CREATE POLICY "admin_update_menu_items"
    ON public.menu_items
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_items.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can delete menu items from their restaurant
CREATE POLICY "admin_delete_menu_items"
    ON public.menu_items
    FOR DELETE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_items.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager')
        )
    );

-- =====================================================
-- STEP 5: modifier_groups - Tenant-Aware Policies
-- =====================================================

-- Public can view all modifier groups (needed for menu customization)
CREATE POLICY "public_view_modifier_groups"
    ON public.modifier_groups
    FOR SELECT
    USING (true);

-- Admins can view modifier groups from their restaurant or all (if super admin)
CREATE POLICY "admin_view_modifier_groups"
    ON public.modifier_groups
    FOR SELECT
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = modifier_groups.restaurant_id
            )
        )
    );

-- Admins can create modifier groups for their restaurant
CREATE POLICY "admin_create_modifier_groups"
    ON public.modifier_groups
    FOR INSERT
    TO authenticated
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = modifier_groups.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can update modifier groups in their restaurant
CREATE POLICY "admin_update_modifier_groups"
    ON public.modifier_groups
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = modifier_groups.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can delete modifier groups from their restaurant
CREATE POLICY "admin_delete_modifier_groups"
    ON public.modifier_groups
    FOR DELETE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = modifier_groups.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager')
        )
    );

-- =====================================================
-- STEP 6: modifier_options - Tenant-Aware Policies
-- =====================================================

-- Public can view all modifier options
CREATE POLICY "public_view_modifier_options"
    ON public.modifier_options
    FOR SELECT
    USING (true);

-- Admins can view modifier options from their restaurant or all (if super admin)
CREATE POLICY "admin_view_modifier_options"
    ON public.modifier_options
    FOR SELECT
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = modifier_options.restaurant_id
            )
        )
    );

-- Admins can create modifier options for their restaurant
CREATE POLICY "admin_create_modifier_options"
    ON public.modifier_options
    FOR INSERT
    TO authenticated
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = modifier_options.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can update modifier options in their restaurant
CREATE POLICY "admin_update_modifier_options"
    ON public.modifier_options
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = modifier_options.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can delete modifier options from their restaurant
CREATE POLICY "admin_delete_modifier_options"
    ON public.modifier_options
    FOR DELETE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = modifier_options.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager')
        )
    );

-- =====================================================
-- STEP 7: menu_item_modifiers - Tenant-Aware Policies
-- =====================================================

-- Public can view all menu item modifier associations
CREATE POLICY "public_view_menu_item_modifiers"
    ON public.menu_item_modifiers
    FOR SELECT
    USING (true);

-- Admins can view associations from their restaurant or all (if super admin)
CREATE POLICY "admin_view_menu_item_modifiers"
    ON public.menu_item_modifiers
    FOR SELECT
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_item_modifiers.restaurant_id
            )
        )
    );

-- Admins can create associations for their restaurant
CREATE POLICY "admin_create_menu_item_modifiers"
    ON public.menu_item_modifiers
    FOR INSERT
    TO authenticated
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_item_modifiers.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can update associations in their restaurant
CREATE POLICY "admin_update_menu_item_modifiers"
    ON public.menu_item_modifiers
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_item_modifiers.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can delete associations from their restaurant
CREATE POLICY "admin_delete_menu_item_modifiers"
    ON public.menu_item_modifiers
    FOR DELETE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_item_modifiers.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager')
        )
    );

-- =====================================================
-- STEP 8: menu_item_variants - Tenant-Aware Policies
-- =====================================================

-- Public can view all menu item variants
CREATE POLICY "public_view_menu_item_variants"
    ON public.menu_item_variants
    FOR SELECT
    USING (true);

-- Admins can view variants from their restaurant or all (if super admin)
CREATE POLICY "admin_view_menu_item_variants"
    ON public.menu_item_variants
    FOR SELECT
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_item_variants.restaurant_id
            )
        )
    );

-- Admins can create variants for their restaurant
CREATE POLICY "admin_create_menu_item_variants"
    ON public.menu_item_variants
    FOR INSERT
    TO authenticated
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_item_variants.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can update variants in their restaurant
CREATE POLICY "admin_update_menu_item_variants"
    ON public.menu_item_variants
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_item_variants.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can delete variants from their restaurant
CREATE POLICY "admin_delete_menu_item_variants"
    ON public.menu_item_variants
    FOR DELETE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_item_variants.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager')
        )
    );

-- =====================================================
-- STEP 9: menu_item_ingredients - Tenant-Aware Policies
-- =====================================================

-- Public can view ingredients for available menu items
CREATE POLICY "public_view_menu_item_ingredients"
    ON public.menu_item_ingredients
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.menu_items
            WHERE menu_items.id = menu_item_ingredients.menu_item_id
            AND menu_items.is_available = true
        )
    );

-- Admins can view ingredients from their restaurant or all (if super admin)
CREATE POLICY "admin_view_menu_item_ingredients"
    ON public.menu_item_ingredients
    FOR SELECT
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_item_ingredients.restaurant_id
            )
        )
    );

-- Admins can create ingredients for their restaurant
CREATE POLICY "admin_create_menu_item_ingredients"
    ON public.menu_item_ingredients
    FOR INSERT
    TO authenticated
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_item_ingredients.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can update ingredients in their restaurant
CREATE POLICY "admin_update_menu_item_ingredients"
    ON public.menu_item_ingredients
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_item_ingredients.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can delete ingredients from their restaurant
CREATE POLICY "admin_delete_menu_item_ingredients"
    ON public.menu_item_ingredients
    FOR DELETE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = menu_item_ingredients.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager')
        )
    );

-- =====================================================
-- STEP 10: promotional_images - Tenant-Aware Policies
-- =====================================================

-- Public can view active promotions that are within their date range
CREATE POLICY "public_view_active_promotions"
    ON public.promotional_images
    FOR SELECT
    USING (
        is_active = true
        AND (start_date IS NULL OR start_date <= now())
        AND (end_date IS NULL OR end_date >= now())
    );

-- Admins can view promotions from their restaurant or all (if super admin)
CREATE POLICY "admin_view_promotional_images"
    ON public.promotional_images
    FOR SELECT
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = promotional_images.restaurant_id
            )
        )
    );

-- Admins can create promotions for their restaurant
CREATE POLICY "admin_create_promotional_images"
    ON public.promotional_images
    FOR INSERT
    TO authenticated
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = promotional_images.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can update promotions in their restaurant
CREATE POLICY "admin_update_promotional_images"
    ON public.promotional_images
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = promotional_images.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager', 'editor')
        )
    );

-- Admins can delete promotions from their restaurant
CREATE POLICY "admin_delete_promotional_images"
    ON public.promotional_images
    FOR DELETE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.admin_users
            WHERE admin_users.id = auth.uid()
            AND (
                admin_users.is_super_admin = true
                OR admin_users.restaurant_id = promotional_images.restaurant_id
            )
            AND admin_users.role IN ('super_admin', 'admin', 'manager')
        )
    );

-- =====================================================
-- SUCCESS MESSAGE
-- =====================================================

DO $$
BEGIN
    RAISE NOTICE '✅ Migration 20250114_003_update_rls_policies_multi_tenant.sql completed successfully';
    RAISE NOTICE '🔒 Updated RLS policies for all tables to be tenant-aware:';
    RAISE NOTICE '   - admin_users: Super admin and restaurant-scoped access';
    RAISE NOTICE '   - categories: Public view + tenant-scoped admin access';
    RAISE NOTICE '   - menu_items: Public view + tenant-scoped admin access';
    RAISE NOTICE '   - modifier_groups: Public view + tenant-scoped admin access';
    RAISE NOTICE '   - modifier_options: Public view + tenant-scoped admin access';
    RAISE NOTICE '   - menu_item_modifiers: Public view + tenant-scoped admin access';
    RAISE NOTICE '   - menu_item_variants: Public view + tenant-scoped admin access';
    RAISE NOTICE '   - menu_item_ingredients: Public view + tenant-scoped admin access';
    RAISE NOTICE '   - promotional_images: Public view with date filtering + tenant-scoped admin access';
    RAISE NOTICE '✅ All policies enforce proper data isolation between restaurants';
    RAISE NOTICE '🎯 Super admins have cross-tenant access, restaurant admins have single-tenant access';
END $$;
